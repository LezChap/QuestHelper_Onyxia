#!/usr/bin/env lua

-- Reads comments from lua files and uses them to generate documentation. Why? Because having
-- the documentation in the same location as stuff that's being documented makes life easier.

-- You can probably read this file for examples on how to document stuff.

loadfile("dump.lua")()
loadfile("fileutil.lua")()

local items = {}

-- object = getObject(name, list)
-- .name (string) The name of the documented item.
-- .list (table) The table to search for the item in.
-- .object (docobj) The object to 
local function getObject(name, list)
  if not list then
    list = items
  end
  
  local _, _, real_name, remainder = string.find(name, "(.-)[%.:](.+)")
  
  if real_name then
    name = real_name
  end
  
  local item = items[name]
  if not item then
    item = {}
    items[name] = item
    
    item.name = name
    item.type = "<unknown>"
    item.file = "<unknown>"
    item.line = -1
    
    item.children = {}
    item.notes = {}
  end
  
  if remainder then
    return getObject(remainder, item.children)
  else
    return item
  end
end

-- valid = isVariableString(var)
-- var (string) The name of a variable.
-- valid (boolean) True if var is a valid variable name.
-- Checks if a string would make a valid variable name.
local function isVariableString(var)
  return string.len(var) > 0 and string.find(var, "^[%a_][%a%d_]*$")
end

-- array = readList(list)
-- list (string) A comma seperated list of items.
-- array (array) The list, broken up into tokens.
-- Breaks string containing a comma seperated list of items into tokens.
-- Returns nil if the list couldn't be parsed.
local function readVariableList(list)
  local result = {}
  
  for arg in string.gmatch(list, "%s*([^,%s]+)%s*,?") do
    if isVariableString(arg) then
      table.insert(result, arg)
    else
      return nil
    end
  end
  
  return result
end

-- name, arguments, returns = readFunctionLine(line)
-- line (string) The line to read.
-- name(string) The name of the function.
-- arguments (array) An array of arguments to the function.
-- returns (array) An array of return values from the function.
-- Returns nothing if it couldn't parse the line.
local function readFunctionLine(line)
  local function_chunk, argument_chunk = select(3, string.find(line, "^(.-)%((.*)%)%s*$"))
  if not function_chunk then return end
  
  local return_chunk, function_name_chunk = select(3, string.find(function_chunk, "^(.*)=%s*([^%s]+)%s*$"))
  
  if not function_name_chunk then
    return_chunk, function_name_chunk = "", select(3, string.find(function_chunk, "^%s*([^%s]+)%s*$"))
  end
  
  if function_name_chunk then
    local arguments, returns = readVariableList(argument_chunk), readVariableList(return_chunk)
    
    if arguments and returns then
      return function_name_chunk, arguments, returns
    end
  end
end

-- processComment(file, line, comment)
-- file (string) The name of the file the comment came from.
-- line (number) The line number of the file the comment came from.
-- comment (table) An array of strings, the lines making up the comment.
-- Parses comments to extract information from them.
local function processComment(file, line, comment)
  local func, arg, ret = readFunctionLine(comment[1])
  
  if func then
    print((next(ret) and table.concat(ret, ", ") or "<nil>").." = "..func.."("..table.concat(arg, ", ")..")")
  end
  
  -- TODO: Parse comments.
  
  --for i, line in ipairs(comment) do
  --  print(line)
  --end
end

-- clearTable(tbl)
-- tbl (table) The table to clear.
-- Goes through a table and deletes all its keys.
local function clearTable(tbl)
  for key in pairs(tbl) do
    tbl[key] = nil
  end
end

-- readLuaFile(file)
-- file (string) The name of the file to read.
-- Reads the comments from a file and passes the comments to [processComment]
local function readLuaFile(file)
  local stream = io.open(file, "r")
  
  if not stream then
    print("Unable to open file: "..file)
    return
  end
  
  local comment = {}, comment_line, comment_type
  
  local line_number = 0
  local line_remainder
  
  while true do
    local line
    if line_remainder and line_remainder ~= "" then
      line = line_remainder
      line_remainder = nil
    else
      line_number = line_number + 1
      line = stream:read()
      if not line then break end
    end
    
    if next(comment) and comment_type == 2 then
      local comment_text
      comment_text, line_remainder = select(3, string.find(line, "^%s*(.-)%s*%]%](.*)"))
      
      
      if comment_text then
        table.insert(comment, comment_text)
        processComment(file, comment_line, comment)
        clearTable(comment)
      else
        table.insert(comment, line)
      end
    else
      local comment_text = select(3, string.find(line, "^%s*%-%-%[%[%s*(.-)%s*$"))
      
      if comment_text then
        if next(comment) then
          processComment(file, comment_line, comment)
          clearTable(comment)
        end
        
        local short_text
        short_text, line_remainder = select(3, string.find(comment_text, "^(.-)%s*%]%](.*)"))
        
        if short_text then
          table.insert(comment, short_text)
          processComment(file, line, comment)
          clearTable(comment)
        else
          table.insert(comment, comment_text)
          comment_type = 2
          comment_line = line_number
        end
      else
        comment_text = select(3, string.find(line, "^%s*%-%-%s*(.-)%s*$"))
        if comment_text then
          if next(comment) then
            table.insert(comment, comment_text)
          else
            table.insert(comment, comment_text)
            comment_type = 1
            comment_line = line_number
          end
        elseif next(comment) then
          processComment(file, comment_line, comment)
          clearTable(comment)
        end
      end
    end
  end
  
  if next(comment) then
    processComment(file, comment_line, comment)
  end
  
  io.close(stream)
end

for i, file in ipairs(arg) do
  readLuaFile(file)
end

local WriteDocObject

local function WriteDocObjectList(list, buffer)
  local array = {}
  for key in pairs(list) do
    table.insert(array, key)
  end
  
  table.sort(array)
  
  for i, key in ipairs(array) do
    WriteDocObject(list[key], buffer)
  end
end

WriteDocObject = function(obj, buffer)
  buffer:add("<div class=item>"..obj.name.."</div>")
end

local function WritePage(filename, title, list)
  local buffer = CreateBuffer()
  buffer:add(string.format(
[[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <title>%s</title>
</head><body>
]], title))

  WriteDocObjectList(list, buffer)
  buffer:add("</body></html>")
  
  local stream = io.open(filename, "w")
  if stream then
    stream:write(buffer:dump())
    io.close(stream)
  else
    print("Unable to write file: "..filename)
  end
end

FileUtil.createDirectory("API")
WritePage("API/api.xhtml", "QuestHelper API Documentation", items)
